{"version":3,"sources":["components/Header/index.jsx","components/Container.jsx","components/Button/index.jsx","components/AlgoSelector.jsx","components/Description.jsx","Graph/components/Vertex.js","Graph/components/Edge.js","Graph/data-model/Graph.js","Graph/data-model/Edge.js","Graph/data-model/Vertex.js","Graph/index.js","Graph/H.js","Graph/algorithms/Prim/index.js","Graph/algorithms/Kruskal/index.js","App.js","index.js"],"names":["Header","react_default","a","createElement","className","Component","Container","style","width","maxWidth","alignSelf","flexGrow","this","props","children","Button","_ref","onClick","_ref$label","label","AlgoSelector","_this$props","algorithms","selectedAlgorithm","onSelect","onConfirm","length","map","algo","components_Button","key","Description","content","prim","href","target","kruskal","includes","Vertex","x","y","_ref$selected","selected","cx","cy","r","stroke","strokeWidth","fill","Edge","_ref$weight","weight","x1","x2","y1","y2","xMid","undefined","yMid","Graph","Object","classCallCheck","vertices","Map","edges","createClass","value","newVertex","has","set","vertexKey","get","vertex","neighbors","Array","from","values","edge","startVertex","getVertexByKey","endVertex","addVertex","Error","addEdge","delete","deleteEdge","findEdge","keys","getAllEdges","reduce","graphEdge","size","arguments","tmp","startVertexKey","endVertexKey","concat","push","filter","e","requiredEdge","find","_this","sort","b","toLowerCase","v","i","_Component","possibleConstructorReturn","getPrototypeOf","apply","inherits","height","xmlns","H","endpoints","edgeSorter","App","call","onAlgoSelect","algorithm","setState","onAlgoConfirm","showAlgoSelector","showAlgoDescription","showMST","algorithmComplete","state","graph","primTree","kruskalTree","datamodel","forEach","seed","minimumSpanningTree","visitedVertices","getAllVertices","getEdges","order","currentMinEdge","shift","nextMinVertex","components","getVerticesKeys","_loop","currentEdge","c1","component","c2","indexOf","union","toConsumableArray","splice","_this$state","graphToRender","components_Header","components_Container","src_Graph_Graph","Edge_Edge","Vertex_Vertex","components_AlgoSelector","components_Description","join","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.417dc9d5.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Header.css\";\n\nclass Header extends Component {\n   render() {\n      return (\n         <header className=\"App-header\">\n            <div className=\"home-link\">\n               <h1 className=\"title\">MST Algorithms</h1>\n            </div>\n         </header>\n      );\n   }\n}\n\nexport default Header;\n","import React, { Component } from \"react\";\n\nclass Container extends Component {\n   render() {\n      return (\n         <div\n            style={{\n               width: \"80%\",\n               maxWidth: \"1120px\",\n               alignSelf: \"center\",\n               flexGrow: 1\n            }}\n         >\n            {this.props.children}\n         </div>\n      );\n   }\n}\n\nexport default Container;\n","import React from \"react\";\nimport \"./Button.css\";\n\nconst Button = ({ onClick, label = \"Label\" }) => {\n   return (\n      <button className=\"button\" onClick={onClick}>\n         {label}\n      </button>\n   );\n};\n\nexport default Button;\n","import React, { Component } from \"react\";\nimport Button from \"./Button\";\n\nclass AlgoSelector extends Component {\n   render() {\n      const { algorithms, selectedAlgorithm, onSelect, onConfirm } = this.props;\n      return (\n         <div>\n            <h2>\n               {selectedAlgorithm.length > 0\n                  ? selectedAlgorithm\n                  : \"Select an Algorithm\"}\n            </h2>\n            <div className=\"buttonarea\">\n               {algorithms.map(algo => (\n                  <Button key={algo} onClick={onSelect(algo)} label={algo} />\n               ))}\n               {selectedAlgorithm && (\n                  <Button onClick={onConfirm} label=\"Next\" />\n               )}\n            </div>\n         </div>\n      );\n   }\n}\n\nexport default AlgoSelector;\n","import React, { Component } from \"react\";\n\nclass Description extends Component {\n   render() {\n      const prim = (\n         <div className=\"content\">\n            <h2>Prim's Algorithm</h2>\n            <p>\n               Prim's algorithm finds a Minimum Spanning Tree (MST) by starting\n               with a seed vertex, and greedily selecting edges with the lowest\n               cost that connect the component containing the seed to the\n               graph's other components. The algorithm is complete once all of\n               the nodes are connected.\n            </p>\n            <p>\n               More detailed info can be found{\" \"}\n               <a\n                  href=\"https://en.wikipedia.org/wiki/Prim%27s_algorithm\"\n                  target=\"blank\"\n               >\n                  here\n               </a>\n            </p>\n            <p>\n               Here we've selected <strong>A</strong> as the seed. Click below\n               to get started.\n            </p>\n         </div>\n      );\n\n      const kruskal = (\n         <div className=\"content\">\n            <h2>Kruskal's Algorithm</h2>\n            <p>\n               Kruskal's algorithm finds a Minimum Spanning Tree (MST) by\n               examining every edge at once, and adding the lowest weight edges\n               which do not create cycles to the graph. The algorithm is\n               complete once all of the nodes are connected.\n            </p>\n            <p>\n               More detailed info can be found{\" \"}\n               <a\n                  href=\"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\"\n                  target=\"blank\"\n               >\n                  here\n               </a>\n            </p>\n            <p>Click below to get started.</p>\n         </div>\n      );\n\n      let content;\n      if (this.props.algo.includes(\"prim\")) {\n         content = prim;\n      }\n      if (this.props.algo.includes(\"kruskal\")) {\n         content = kruskal;\n      }\n      return content;\n   }\n}\n\nexport default Description;\n","import React from \"react\";\n\nexport const Vertex = ({ x, y, label, selected = false }) => {\n   return (\n      <g>\n         <circle\n            cx={x}\n            cy={y}\n            r={20}\n            stroke={selected ? \"black\" : \"blue\"}\n            strokeWidth={4}\n            fill={selected ? \"red\" : \"#61dafb\"}\n         />\n         <text x={x - 5} y={y + 5}>\n            {label}\n         </text>\n      </g>\n   );\n};\n","import React from \"react\";\n\nexport const Edge = ({ selected = false, weight = 1, x1, x2, y1, y2 }) => {\n   let slope;\n   if (x1 < x2) {\n      slope = (y2 - y1) / (x2 - x1);\n   } else if (x1 > x2) {\n      slope = (y1 - y2) / (x1 - x2);\n   } else {\n      slope = undefined;\n   }\n   let xOffset = slope < 0 ? 6 : 0;\n   let xMid = (x2 + x1) / 2 - xOffset;\n   let yMid = (y2 + y1) / 2;\n   return (\n      <g>\n         <line\n            stroke={selected ? \"red\" : \"black\"}\n            strokeWidth=\"4\"\n            x1={x1}\n            x2={x2}\n            y1={y1}\n            y2={y2}\n         />\n         <text x={xMid} y={yMid} fill=\"#61dafb\">\n            {weight}\n         </text>\n      </g>\n   );\n};\nexport default Edge;\n","export class Graph {\n   /**\n    * @param {boolean} isDirected\n    */\n   constructor() {\n      this.vertices = new Map();\n      this.edges = new Map();\n   }\n\n   /**\n    * @property {number} weight - Sum of all edge weights in this graph\n    */\n   get weight() {\n      return this.getAllEdges().reduce((weight, graphEdge) => {\n         return weight + graphEdge.weight;\n      }, 0);\n   }\n\n   /**\n    * @property {number} order - The number of vertices in this graph\n    */\n   get order() {\n      return this.vertices.size;\n   }\n\n   /**\n    * @property {number} size - The number of edges in this graph\n    */\n   get size() {\n      return this.edges.size;\n   }\n\n   /**\n    * @param {GraphVertex} newVertex\n    * @returns {Graph}\n    */\n   addVertex(newVertex) {\n      if (!this.vertices.has(newVertex.key)) {\n         this.vertices.set(newVertex.key, newVertex);\n      }\n\n      return this;\n   }\n\n   /**\n    * @param {string} vertexKey\n    * @returns {GraphVertex|undefined}\n    */\n   getVertexByKey(vertexKey) {\n      if (this.vertices.has(vertexKey)) {\n         return this.vertices.get(vertexKey);\n      }\n   }\n\n   /**\n    * @param {GraphVertex} vertex\n    * @returns {GraphVertex[]}\n    */\n   getNeighbors(vertex) {\n      return vertex.neighbors;\n   }\n\n   /**\n    * @return {GraphVertex[]}\n    */\n   getAllVertices() {\n      return Array.from(this.vertices.values());\n   }\n\n   /**\n    * @return {GraphEdge[]}\n    */\n   getAllEdges() {\n      return Array.from(this.edges.values());\n   }\n\n   /**\n    * @param {GraphEdge} edge\n    * @returns {Graph}\n    */\n   addEdge(edge) {\n      // Try to find and end start vertices.\n      let startVertex = this.getVertexByKey(edge.startVertex.key);\n      let endVertex = this.getVertexByKey(edge.endVertex.key);\n\n      // Insert start vertex if it wasn't inserted.\n      if (!startVertex) {\n         this.addVertex(edge.startVertex);\n         startVertex = this.getVertexByKey(edge.startVertex.key);\n      }\n\n      // Insert end vertex if it wasn't inserted.\n      if (!endVertex) {\n         this.addVertex(edge.endVertex);\n         endVertex = this.getVertexByKey(edge.endVertex.key);\n      }\n\n      // Check if edge has been already added.\n      if (this.edges.has(edge.key)) {\n         throw new Error(\"Edge has already been added before\");\n      } else {\n         this.edges.set(edge.key, edge);\n      }\n\n      // Add edge to the vertices.\n      startVertex.addEdge(edge);\n      endVertex.addEdge(edge);\n\n      return this;\n   }\n\n   /**\n    * @param {GraphEdge} edge\n    */\n   deleteEdge(edge) {\n      // Delete edge from the list of edges.\n      if (this.edges.has(edge.key)) {\n         this.edges.delete(edge.key);\n      } else {\n         throw new Error(\"Edge not found in graph\");\n      }\n\n      // Try to find and end start vertices and delete edge from them.\n      const startVertex = this.getVertexByKey(edge.startVertex.key);\n      const endVertex = this.getVertexByKey(edge.endVertex.key);\n\n      startVertex.deleteEdge(edge);\n      endVertex.deleteEdge(edge);\n   }\n\n   /**\n    * @param {GraphVertex} startVertex\n    * @param {GraphVertex} endVertex\n    * @return {(GraphEdge|undefined)}\n    */\n   findEdge(startVertex, endVertex) {\n      const vertex = this.getVertexByKey(startVertex.key);\n\n      if (!vertex) {\n         return undefined;\n      }\n\n      return vertex.findEdge(endVertex);\n   }\n\n   /**\n    * @param {string} vertexKey\n    * @returns {GraphVertex}\n    */\n   findVertexByKey(vertexKey) {\n      if (this.vertices.has(vertexKey)) {\n         return this.vertices.get(vertexKey);\n      }\n   }\n\n   /**\n    * @return {string[]}\n    */\n   getVerticesKeys() {\n      return Array.from(this.vertices.keys());\n   }\n}\n","export class Edge {\n   /**\n    * @param {GraphVertex} startVertex\n    * @param {GraphVertex} endVertex\n    * @param {number} [weight=1]\n    */\n   constructor(startVertex, endVertex, weight = 0) {\n      this.startVertex = startVertex;\n      this.endVertex = endVertex;\n      this.weight = weight;\n   }\n\n   /**\n    * @return {string}\n    */\n   get key() {\n      const startVertexKey = this.startVertex.key;\n      const endVertexKey = this.endVertex.key;\n\n      return `${startVertexKey}_${endVertexKey}`;\n   }\n\n   /**\n    * @return {Edge}\n    */\n   reverse() {\n      const tmp = this.startVertex;\n      this.startVertex = this.endVertex;\n      this.endVertex = tmp;\n\n      return this;\n   }\n}\n","export class Vertex {\n   /**\n    * @param {string} key\n    * @param {number} x\n    * @param {number} y\n    */\n   constructor(key, x = 0, y = 0) {\n      if (key === undefined) {\n         throw new Error(\"Vertex must have a key\");\n      }\n      this.key = key;\n      this.x = x;\n      this.y = y;\n      this.edges = [];\n   }\n\n   get degree() {\n      return this.edges.length;\n   }\n\n   get neighbors() {\n      const neighbors = this.edges\n         .map(e => (e.startVertex === this ? e.endVertex : e.startVertex))\n         .sort((a, b) => {\n            if (a.key.toLowerCase() < b.key.toLowerCase()) {\n               return -1;\n            }\n            if (a.key.toLowerCase() > b.key.toLowerCase()) {\n               return 1;\n            }\n\n            return 0;\n         });\n\n      return neighbors.filter((v, i, a) => v !== a[i - 1]);\n   }\n\n   /**\n    * @returns {GraphEdge[]}\n    */\n   getEdges() {\n      return Array.from(this.edges.values());\n   }\n\n   /**\n    * @param {GraphEdge} edge\n    * @returns {Vertex}\n    */\n   addEdge(edge) {\n      if (!this.edges.includes(edge)) {\n         this.edges.push(edge);\n      }\n\n      return this;\n   }\n\n   /**\n    * @param {GraphEdge} edge\n    */\n   deleteEdge(edge) {\n      this.edges = this.edges.filter(e => e !== edge);\n   }\n\n   /**\n    * @return {Vertex}\n    */\n   deleteAllEdges() {\n      this.edges = [];\n\n      return this;\n   }\n\n   /**\n    * @param {GraphEdge} requiredEdge\n    * @returns {boolean}\n    */\n   hasEdge(requiredEdge) {\n      return this.edges.includes(requiredEdge);\n   }\n\n   /**\n    * @param {Vertex} vertex\n    * @returns {boolean}\n    */\n   hasNeighbor(vertex) {\n      return this.neighbors.includes(vertex);\n   }\n\n   /**\n    * @param {Vertex} vertex\n    * @returns {(GraphEdge|null)}\n    */\n   findEdge(vertex) {\n      return this.edges.find(\n         e => e.startVertex === vertex || e.endVertex === vertex\n      );\n   }\n}\n","import React, { Component } from \"react\";\nimport \"./graph.css\";\n\nexport class Graph extends Component {\n   render() {\n      return (\n         <svg\n            className=\"graph\"\n            width=\"450\"\n            height=\"450\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n         >\n            {this.props.children}\n         </svg>\n      );\n   }\n}\n\nexport { Vertex } from \"./components/Vertex.js\";\nexport { Edge } from \"./components/Edge\";\n\nexport * from \"./data-model\";\n","export default {\n   vertices: [\n      {\n         label: \"A\",\n         x: 175,\n         y: 70\n      },\n      {\n         label: \"B\",\n         x: 110,\n         y: 150\n      },\n      {\n         label: \"C\",\n         x: 260,\n         y: 150\n      },\n      {\n         label: \"D\",\n         x: 205,\n         y: 220\n      },\n      {\n         label: \"E\",\n         x: 330,\n         y: 300\n      },\n      {\n         label: \"F\",\n         x: 140,\n         y: 365\n      }\n   ],\n\n   edges: [\n      {\n         endpoints: [\"A\", \"B\"],\n         weight: 4\n      },\n      {\n         endpoints: [\"A\", \"C\"],\n         weight: 2\n      },\n      {\n         endpoints: [\"B\", \"C\"],\n         weight: 1\n      },\n      {\n         endpoints: [\"B\", \"D\"],\n         weight: 5\n      },\n      {\n         endpoints: [\"C\", \"D\"],\n         weight: 8\n      },\n      {\n         endpoints: [\"C\", \"E\"],\n         weight: 10\n      },\n      {\n         endpoints: [\"D\", \"E\"],\n         weight: 2\n      },\n      {\n         endpoints: [\"D\", \"F\"],\n         weight: 6\n      },\n      {\n         endpoints: [\"E\", \"F\"],\n         weight: 5\n      }\n   ]\n};\n","import { Graph } from \"../../data-model\";\n\n/**\n * @param {Graph} graph\n * @return {Graph}\n */\nexport function prim(graph, seed) {\n   // Init new graph that will contain minimum spanning tree of original graph.\n   const minimumSpanningTree = new Graph();\n\n   // Set of vertices that has been already visited.\n   const visitedVertices = new Map();\n\n   // Vertex from which we will start graph traversal.\n   const startVertex =\n      typeof seed == \"object\" ? seed : graph.getAllVertices()[0];\n\n   // Add start vertex to the set of visited ones.\n   visitedVertices.set(startVertex.key, startVertex);\n\n   // This priority queue will contain all the edges that are starting from\n   // visited nodes and they will be ranked by edge weight - so that on each step\n   // we would always pick the edge with minimal edge weight.\n   let edges = startVertex.getEdges().sort(edgeSorter);\n   // let edgeIterator = edges.values();\n   // let nextEdge = edgeIterator.next();\n\n   // Now let's explore all queued edges.\n   while (minimumSpanningTree.order < graph.order) {\n      // Fetch next queued edge with minimal weight.\n      /** @var {GraphEdge} currentEdge */\n      const currentMinEdge = edges.shift();\n\n      // Find out the next unvisited minimal vertex to traverse.\n      let nextMinVertex = null;\n      if (!visitedVertices.has(currentMinEdge.startVertex.key)) {\n         nextMinVertex = currentMinEdge.startVertex;\n      } else if (!visitedVertices.has(currentMinEdge.endVertex.key)) {\n         nextMinVertex = currentMinEdge.endVertex;\n      }\n\n      // If all vertices of current edge has been already visited then skip this round.\n      if (nextMinVertex) {\n         // Add current min edge to MST.\n         minimumSpanningTree.addEdge(currentMinEdge);\n\n         // Add vertex to the set of visited ones.\n         visitedVertices.set(nextMinVertex.key, nextMinVertex);\n\n         // Add all current vertex's edges to the queue.\n\n         nextMinVertex.getEdges().forEach(graphEdge => {\n            // Add only vertices that link to unvisited nodes.\n            if (\n               !visitedVertices.has(graphEdge.startVertex.key) ||\n               !visitedVertices.has(graphEdge.endVertex.key)\n            ) {\n               edges.push(graphEdge);\n            }\n         });\n\n         edges.sort(edgeSorter);\n      }\n   }\n\n   return minimumSpanningTree;\n}\n\nconst edgeSorter = (a, b) => {\n   if (a.weight - b.weight < 0) {\n      return -1;\n   } else if (a.weight - b.weight > 0) {\n      return 1;\n   }\n\n   return 0;\n};\n","import { Graph } from \"../../data-model\";\n\n/**\n * @param {Graph} graph\n * @return {Graph}\n */\nexport function kruskal(graph) {\n   // Init new graph that will contain minimum spanning tree of original graph.\n   const minimumSpanningTree = new Graph();\n   graph\n      .getAllVertices()\n      .forEach(vertex => minimumSpanningTree.addVertex(vertex));\n\n   const edges = graph.getAllEdges().sort(edgeSorter);\n\n   // Create disjoint sets for all graph vertices.\n   const components = graph.getVerticesKeys().map(key => [key]);\n\n   // Go through all edges started from the minimum one and try to add them\n   // to minimum spanning tree. The criteria of adding the edge would be whether\n   // it is forms the cycle or not (if it connects two vertices from the same component or not).\n   while (components.length > 1) {\n      let currentEdge = edges.shift();\n      const c1 = components.find(component =>\n         component.includes(currentEdge.startVertex.key)\n      );\n      const c2 = components.find(component =>\n         component.includes(currentEdge.endVertex.key)\n      );\n\n      if (components.indexOf(c1) != components.indexOf(c2)) {\n         const index1 = components.indexOf(c1);\n         const index2 = components.indexOf(c2);\n         const union = [...c1, ...c2];\n\n         components.splice(components.indexOf(c1), 1, union);\n         components.splice(components.indexOf(c2), 1);\n         minimumSpanningTree.addEdge(currentEdge);\n      }\n   }\n\n   return minimumSpanningTree;\n}\n\nconst edgeSorter = (a, b) => {\n   if (a.weight - b.weight < 0) {\n      return -1;\n   } else if (a.weight - b.weight > 0) {\n      return 1;\n   }\n\n   return 0;\n};\n","import React, { Component } from \"react\";\nimport Header from \"./components/Header\";\nimport Container from \"./components/Container\";\nimport Button from \"./components/Button\";\nimport AlgoSelector from \"./components/AlgoSelector\";\nimport Description from \"./components/Description\";\n\nimport { Graph, Vertex, Edge } from \"./Graph\";\nimport * as datamodel from \"./Graph/data-model\";\nimport H from \"./Graph/H\";\nimport { prim, kruskal } from \"./Graph/algorithms\";\nimport \"./App.css\";\n\nclass App extends Component {\n   constructor(props) {\n      super(props);\n      this.state = {\n         graph: null,\n         primTree: null,\n         kruskalTree: null,\n         algorithm: \"\",\n         showAlgoSelector: true,\n         showAlgoDescription: false,\n         algorithmComplete: false\n      };\n   }\n\n   componentDidMount() {\n      const graph = new datamodel.Graph();\n      H.vertices.forEach(v => {\n         let vertex = new datamodel.Vertex(v.label, v.x, v.y);\n         graph.addVertex(vertex);\n      });\n      H.edges.forEach(e => {\n         let startVertex = graph.getVertexByKey(e.endpoints[0]);\n         let endVertex = graph.getVertexByKey(e.endpoints[1]);\n         let edge = new datamodel.Edge(startVertex, endVertex, e.weight);\n         graph.addEdge(edge);\n      });\n\n      let primTree = prim(graph);\n      let kruskalTree = kruskal(graph);\n\n      this.setState({\n         graph,\n         primTree,\n         kruskalTree\n      });\n   }\n\n   render() {\n      const {\n         algorithm,\n         showAlgoSelector,\n         showAlgoDescription,\n         graph,\n         primTree,\n         kruskalTree,\n         algorithmComplete\n      } = this.state;\n\n      let graphToRender = graph;\n      if (algorithmComplete) {\n         if (algorithm.includes(\"prim\")) {\n            graphToRender = primTree;\n         }\n\n         if (algorithm.includes(\"kruskal\")) {\n            graphToRender = kruskalTree;\n         }\n      }\n      return (\n         <div className=\"App\">\n            <Header />\n            <Container>\n               <main className=\"main\">\n                  <div className=\"grapharea column\">\n                     <Graph>\n                        {graph &&\n                           graphToRender\n                              .getAllEdges()\n                              .map(e => (\n                                 <Edge\n                                    key={e.key}\n                                    x1={e.startVertex.x}\n                                    x2={e.endVertex.x}\n                                    y1={e.startVertex.y}\n                                    y2={e.endVertex.y}\n                                    weight={e.weight}\n                                 />\n                              ))}\n\n                        {graph &&\n                           graphToRender\n                              .getAllVertices()\n                              .map(v => (\n                                 <Vertex\n                                    key={v.key}\n                                    x={v.x}\n                                    y={v.y}\n                                    label={v.key}\n                                 />\n                              ))}\n                     </Graph>\n                  </div>\n                  <div className=\"textarea column\">\n                     {showAlgoSelector && (\n                        <AlgoSelector\n                           algorithms={[\"Prim's\", \"Kruskal's\"]}\n                           selectedAlgorithm={algorithm}\n                           onSelect={this.onAlgoSelect}\n                           onConfirm={this.onAlgoConfirm}\n                        />\n                     )}\n                     {showAlgoDescription && [\n                        <Description algo={algorithm} />,\n                        <div className=\"buttonarea\">\n                           <Button onClick={this.showMST} label=\"Get Results\" />\n                        </div>\n                     ]}\n                     {algorithmComplete && (\n                        <div>\n                           <h2>Complete!</h2>\n                           <p>MST weight: {`${graphToRender.weight}`}</p>\n                           <p>\n                              Edge selection order:{\" \"}\n                              {graphToRender\n                                 .getAllEdges()\n                                 .map(e => e.key)\n                                 .join(\", \")}\n                           </p>\n                        </div>\n                     )}\n                  </div>\n               </main>\n            </Container>\n         </div>\n      );\n   }\n\n   onAlgoSelect = algorithm => {\n      return () => {\n         this.setState({ algorithm: algorithm.toLowerCase() });\n      };\n   };\n\n   onAlgoConfirm = () => {\n      this.setState({ showAlgoSelector: false, showAlgoDescription: true });\n   };\n\n   showMST = () => {\n      this.setState({ showAlgoDescription: false, algorithmComplete: true });\n   };\n}\n\nconst StartButton = ({ onClick }) => <Button onClick={onClick} label=\"Start\" />;\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}